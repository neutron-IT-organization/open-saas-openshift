# NOTE: Why do we specify alpine version here?
#   Because if not, we had situations where it would use the different version
#   locally and on Github CI. This way we ensure exact version is used,
#   and also have control over updating it (instead of update surprising us).
# Use UBI image for initial setup
FROM node:22.6.0-slim AS ubi-setup
RUN apt-get update -y
RUN DEBIAN_FRONTEND=noninteractive apt-get install npm curl bash -y
RUN node -v

# Set work directory and copy all the files into it
WORKDIR /app
COPY . .

# Install Wasp
RUN curl -sSL https://get.wasp-lang.dev/installer.sh | sh

# Add Wasp to PATH
ENV PATH="/root/.local/bin:${PATH}"

# Run Wasp build
RUN wasp build


FROM node:22.6.0-slim AS node


# We split Dockerfile into base, server-builder and server-production.
# This way we have separate situations -> in server-builder we build all
# we need to run the server, and then in server-production we start fresh
# and just copy what we need from server-builder, avoiding intermediate
# artifacts and any settings / pollution we don't need in production
# but only for building.


FROM node AS base
RUN apt upgrade # To ensure any potential security patches are applied.

# Copy all necessary files from the UBI setup stage
COPY --from=ubi-setup /app/ /app/

# TODO: Use pm2?
# TODO: Use non-root user (node).
FROM base AS web-app-builder
# In case they want to use python3 in their app.
#RUN apk add --no-cache python3
ENV NODE_ENV production
WORKDIR /app
COPY --from=ubi-setup /app/ /app/
EXPOSE 3000
WORKDIR /app/.wasp/build/web-app
RUN npm ci && REACT_APP_API_URL=$REACT_APP_API_URL npm run build
ENTRYPOINT ["npm", "run", "start-production"]


# Any user-defined Dockerfile contents will be appended below.
FROM joseluisq/static-web-server AS web-app-production
ARG PORT
ENV SERVER_PORT=$PORT
COPY --from=web-app-builder /wasp/.wasp/build/web-app/build /public

